enum Rate {
  THUMBS_UP
  THUMBS_DOWN
}

enum Right {
  ADMIN # Can do everything
  EDITOR # Can edit content
  READER # Can read content
}

enum GameName {
  SYNONYM_ROLL
  FAB_VOCAB
  ANTONYM_HUNT
  GRAMMAR_GEEK
  KNOWLYMPICS
}

enum RewardType {
  COINS
  STARS
  STAR_PERCENTAGE
}

type AuthToken {
  token: String!
}

## Users

# Regular users (players)
type User
  @auth(
    rules: [
      {
        operations: [UPDATE, DELETE, CONNECT, DISCONNECT]
        isAuthenticated: true
        roles: [ADMIN]
      }
      { operations: [READ], isAuthenticated: true }
    ]
  ) {
  userId: ID!
  username: String!
  mail: String! @unique
  password: String @private
  coins: Int! @default(value: 0)
  stars: Int! @default(value: 0)
  inventory: [Avatar] @relationship(type: "AVATAR_INVENTORY", direction: IN)
  scores: [Score] @relationship(type: "SCORE_USER", direction: OUT)
  currentAvatar: Avatar @relationship(type: "AVATAR_USER", direction: IN)

  starPercentage: Int! @default(value: 0)
  daysInArow: Int
  isPremium: Boolean! @default(value: false)
  age: Int
  country: String
  actualMoneySpent: Int
  appRate: Rate
  appReview: String
  lastPremiumDate: DateTime
  lastSeen: DateTime
  createdAt: DateTime!
}

# Admin users, who can add/remove/manage content
type SuperUser
  @auth(
    rules: [
      {
        operations: [CREATE, UPDATE, DELETE, CONNECT, DISCONNECT]
        isAuthenticated: true
        roles: [ADMIN]
      }
      {
        operations: [READ]
        isAuthenticated: true
        roles: [ADMIN, READER, EDITOR]
      }
    ]
  ) {
  userId: ID!
  mail: String! @unique
  password: String @private
  firstname: String
  lastname: String
  rights: Right

  createdAt: DateTime
}

## Avatars

type Avatar
  @auth(
    rules: [
      {
        operations: [CREATE, UPDATE, DELETE, CONNECT, DISCONNECT]
        isAuthenticated: true
        roles: [ADMIN, EDITOR]
      }
    ]
  ) {
  avatarId: ID! @id
  name: String! @unique
  picture: String!
  coinPrice: Int!
  collections: [AvatarCollection]
    @relationship(type: "AVATAR_COLLECTION_AVATAR", direction: OUT)
  ownedBy: [User] @relationship(type: "AVATARS_USER", direction: OUT)
  createdAt: DateTime @timestamp(operations: [CREATE])
}

type AvatarCollection
  @auth(
    rules: [
      {
        operations: [CREATE, UPDATE, DELETE, CONNECT, DISCONNECT]
        isAuthenticated: true
        roles: [ADMIN, EDITOR]
      }
    ]
  ) {
  avatarCollectionId: ID! @id
  name: String! @unique
  startDate: DateTime
  endDate: DateTime
  avatars: [Avatar]!
    @relationship(type: "AVATAR_COLLECTION_AVATAR", direction: IN)
  createdAt: DateTime @timestamp(operations: [CREATE])
}

## Games

type Game
  @auth(
    rules: [
      {
        operations: [CREATE, UPDATE, DELETE, CONNECT, DISCONNECT]
        isAuthenticated: true
        roles: [ADMIN, EDITOR]
      }
    ]
  ) {
  gameId: ID! @id
  name: GameName! @unique
  description: String
  scores: [Score] @relationship(type: "SCORE_GAME", direction: IN)
  timer: Int!
}

type Score
  @auth(
    rules: [
      {
        operations: [READ, CREATE, UPDATE, DELETE, CONNECT, DISCONNECT]
        isAuthenticated: true
      }
    ]
  ) {
  scoreId: ID! @id
  user: User! @relationship(type: "SCORE_USER", direction: IN)
  game: Game! @relationship(type: "SCORE_GAME", direction: OUT)
  score: Int!
  createdAt: DateTime @timestamp(operations: [CREATE])
}

type SynonymRollList
  @auth(
    rules: [
      {
        operations: [CREATE, UPDATE, DELETE, CONNECT, DISCONNECT]
        isAuthenticated: true
        roles: [ADMIN, EDITOR]
      }
    ]
  ) {
  synonymId: ID! @id
  synonyms: [String!]!
  createdAt: DateTime @timestamp(operations: [CREATE])
}

type FabVocabQuestion
  @auth(
    rules: [
      {
        operations: [CREATE, UPDATE, DELETE, CONNECT, DISCONNECT]
        isAuthenticated: true
        roles: [ADMIN, EDITOR]
      }
    ]
  ) {
  fabvocabId: ID! @id
  picture: String!
  correctWords: [String!]!
  wrongWords: [String!]!
  correctSentence: String!
  wrongSentences: [String!]!
  createdAt: DateTime @timestamp(operations: [CREATE])
}

type AntonymHuntAssociation
  @auth(
    rules: [
      {
        operations: [CREATE, UPDATE, DELETE, CONNECT, DISCONNECT]
        isAuthenticated: true
        roles: [ADMIN, EDITOR]
      }
    ]
  ) {
  antonymId: ID! @id
  rightWord: String!
  leftWord: String!
  createdAt: DateTime @timestamp(operations: [CREATE])
}

type GrammarGeekQuestion
  @auth(
    rules: [
      {
        operations: [CREATE, UPDATE, DELETE, CONNECT, DISCONNECT]
        isAuthenticated: true
        roles: [ADMIN, EDITOR]
      }
    ]
  ) {
  grammarId: ID! @id
  sentence: String!
  correctWord: String!
  wrongWords: [String!]!
  hint: String
  createdAt: DateTime @timestamp(operations: [CREATE])
}

## Gifts

type Gift
  @auth(
    rules: [
      {
        operations: [CREATE, UPDATE, DELETE, CONNECT, DISCONNECT]
        isAuthenticated: true
        roles: [ADMIN, EDITOR]
      }
    ]
  ) {
  giftId: ID! @id
  day: Int! @unique
  quantity: Int!
  reward: RewardType!
  updatedAt: DateTime @timestamp(operations: [UPDATE])
}

type Mutation {
  # regular users
  signup(mail: String!, username: String!, password: String!): AuthToken
  login(mail: String!, password: String!): AuthToken

  googleSignup(token: String): AuthToken
  googleLogin(token: String): AuthToken

  updateCurrentUser(
    username: String
    mail: String
    password: String
    isPremium: Boolean
    coins: Int
    starPercentage: Int
    stars: Int
  ): User

  # super users
  forbiddenSuperSignup(
    mail: String!
    firstname: String
    lastname: String
    password: String!
    rights: Right
  ): AuthToken

  superSignup(
    token: String!
    firstname: String
    lastname: String
    password: String!
  ): AuthToken

  superLogin(mail: String!, password: String!): AuthToken

  # returns authentication url
  inviteSuperUser(mail: String!, rights: Right!): String

  #Users and gifts management
  updateLastSeen(daysInArow: Int): User

  #avatars and users
  addAvatarToInventory(avatarId: ID!): Avatar
    @cypher(
      statement: """
      MATCH (avatar:Avatar {avatarId: $avatarId})
      MATCH (user:User {userId: $auth.jwt.userId})
      MERGE (avatar)-[r:AVATAR_INVENTORY]->(user)
      RETURN avatar
      """
    )
  buyAvatar(avatarId: ID!, price: Int!): User
    @cypher(
      statement: """
      MATCH (avatar:Avatar {avatarId: $avatarId})
      MATCH (user:User {userId: $auth.jwt.userId})
      MERGE (avatar)-[r:AVATAR_INVENTORY]->(user)
      SET user.coins = user.coins - $price
      RETURN user
      """
    )
  changeCurrentAvatar(avatarId: ID!): Avatar
    @cypher(
      statement: """
      MATCH (avatar:Avatar {avatarId: $avatarId})
      MATCH (user:User {userId: $auth.jwt.userId})
      OPTIONAL MATCH ()-[old:AVATAR_USER]->(user)
      MERGE (avatar)-[r:AVATAR_USER]->(user)
      DELETE old
      RETURN avatar
      """
    )

  ##avatars add avatar to collection##
  addAvatarToCollection(
    avatarId: ID!
    avatarCollectionId: ID!
  ): AvatarCollection
    @cypher(
      statement: """
      MATCH (avatar:Avatar {avatarId: $avatarId})
      MATCH (collection:AvatarCollection {avatarCollectionId: $avatarCollectionId})
      MERGE (avatar)-[r:AVATAR_COLLECTION_AVATAR]->(collection)
      RETURN collection
      """
    )

  addAvatarsToCollection(
    avatarIds: [ID!]!
    avatarCollectionId: ID!
  ): AvatarCollection
    @cypher(
      statement: """
      MATCH (avatar:Avatar) WHERE avatar.avatarId IN $avatarIds
      MATCH (collection:AvatarCollection {avatarCollectionId: $avatarCollectionId})
      MERGE (avatar)-[r:AVATAR_COLLECTION_AVATAR]->(collection)
      RETURN collection
      """
    )

  toggleAvatarsToCollection(
    avatarIds: [ID!]!
    avatarCollectionId: ID!
  ): AvatarCollection
    @cypher(
      statement: """
      MATCH (avatar:Avatar) WHERE avatar.avatarId IN $avatarIds
      MATCH (collection:AvatarCollection {avatarCollectionId: $avatarCollectionId})
      OPTIONAL MATCH (avatar)-[oldR:AVATAR_COLLECTION_AVATAR]->(collection)
      MERGE (avatar)-[r:AVATAR_COLLECTION_AVATAR]->(collection)
      DELETE oldR
      WITH collection
      RETURN collection
      """
    )

  ## Games

  addNewScore(gameName: GameName!, score: Int!): Score
    @cypher(
      statement: """
      MATCH (game:Game {name: $gameName})
      MATCH (user:User {userId: $auth.jwt.userId})
      MERGE (user)-[r:SCORE_USER]->(s:Score {score: $score})-[r2:SCORE_GAME]->(game)
      RETURN s
      """
    )
  updateScore(gameName: GameName!, score: Int!): Score
    @cypher(
      statement: """
      MATCH (game:Game {name: $gameName})
      MATCH (user:User {userId: $auth.jwt.userId})
      MATCH (user)-[r:SCORE_USER]->(s:Score)-[r2:SCORE_GAME]->(game)
      set s.score = $score
      RETURN s
      """
    )
}

type Query {
  # regular users
  currentUser: User
    @cypher(
      statement: """
      MATCH (u:User {userId: $auth.jwt.userId})
      RETURN u
      """
    )

  # super users
  superCurrentUser: SuperUser
    @cypher(
      statement: """
      MATCH (u:SuperUser {userId: $auth.jwt.userId})
      RETURN u
      """
    )

  ## Games
  # Synonym Roll
  randomSynonyms(limit: Int!): [SynonymRollList]
    @cypher(
      statement: """
      MATCH (syn:SynonymRollList)
      RETURN syn
      ORDER BY rand()
      LIMIT $limit;
      """
    )
  # GrammarGeek
  randomGrammarGeek(limit: Int!): [GrammarGeekQuestion]
    @cypher(
      statement: """
      MATCH (gram:GrammarGeekQuestion)
      RETURN gram
      ORDER BY rand()
      LIMIT $limit;
      """
    )
  # Antonym Hunt
  randomAntonyms(limit: Int!): [AntonymHuntAssociation]
    @cypher(
      statement: """
      MATCH (ant:AntonymHuntAssociation)
      RETURN ant
      ORDER BY rand()
      LIMIT $limit;
      """
    )
  # Fab Vocab
  randomFabVocab(limit: Int!): [FabVocabQuestion]
    @cypher(
      statement: """
      MATCH (fab:FabVocabQuestion)
      RETURN fab
      ORDER BY rand()
      LIMIT $limit;
      """
    )
}
